// Code generated by Prisma (prisma@1.21.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  exclusion: (where?: ExclusionWhereInput) => Promise<boolean>;
  fragment: (where?: FragmentWhereInput) => Promise<boolean>;
  label: (where?: LabelWhereInput) => Promise<boolean>;
  rule: (where?: RuleWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  stream: (where?: StreamWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  exclusion: (where: ExclusionWhereUniqueInput) => ExclusionPromise;
  exclusions: (
    args?: {
      where?: ExclusionWhereInput;
      orderBy?: ExclusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Exclusion>;
  exclusionsConnection: (
    args?: {
      where?: ExclusionWhereInput;
      orderBy?: ExclusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExclusionConnectionPromise;
  fragment: (where: FragmentWhereUniqueInput) => FragmentPromise;
  fragments: (
    args?: {
      where?: FragmentWhereInput;
      orderBy?: FragmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Fragment>;
  fragmentsConnection: (
    args?: {
      where?: FragmentWhereInput;
      orderBy?: FragmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentConnectionPromise;
  label: (where: LabelWhereUniqueInput) => LabelPromise;
  labels: (
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Label>;
  labelsConnection: (
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LabelConnectionPromise;
  rule: (where: RuleWhereUniqueInput) => RulePromise;
  rules: (
    args?: {
      where?: RuleWhereInput;
      orderBy?: RuleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Rule>;
  rulesConnection: (
    args?: {
      where?: RuleWhereInput;
      orderBy?: RuleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RuleConnectionPromise;
  schedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  schedules: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Schedule>;
  schedulesConnection: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServicePromise;
  services: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Service>;
  servicesConnection: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ServiceConnectionPromise;
  stream: (where: StreamWhereUniqueInput) => StreamPromise;
  streams: (
    args?: {
      where?: StreamWhereInput;
      orderBy?: StreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Stream>;
  streamsConnection: (
    args?: {
      where?: StreamWhereInput;
      orderBy?: StreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StreamConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createExclusion: (data: ExclusionCreateInput) => ExclusionPromise;
  updateExclusion: (
    args: { data: ExclusionUpdateInput; where: ExclusionWhereUniqueInput }
  ) => ExclusionPromise;
  updateManyExclusions: (
    args: {
      data: ExclusionUpdateManyMutationInput;
      where?: ExclusionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExclusion: (
    args: {
      where: ExclusionWhereUniqueInput;
      create: ExclusionCreateInput;
      update: ExclusionUpdateInput;
    }
  ) => ExclusionPromise;
  deleteExclusion: (where: ExclusionWhereUniqueInput) => ExclusionPromise;
  deleteManyExclusions: (where?: ExclusionWhereInput) => BatchPayloadPromise;
  createFragment: (data: FragmentCreateInput) => FragmentPromise;
  updateFragment: (
    args: { data: FragmentUpdateInput; where: FragmentWhereUniqueInput }
  ) => FragmentPromise;
  updateManyFragments: (
    args: { data: FragmentUpdateManyMutationInput; where?: FragmentWhereInput }
  ) => BatchPayloadPromise;
  upsertFragment: (
    args: {
      where: FragmentWhereUniqueInput;
      create: FragmentCreateInput;
      update: FragmentUpdateInput;
    }
  ) => FragmentPromise;
  deleteFragment: (where: FragmentWhereUniqueInput) => FragmentPromise;
  deleteManyFragments: (where?: FragmentWhereInput) => BatchPayloadPromise;
  createLabel: (data: LabelCreateInput) => LabelPromise;
  updateLabel: (
    args: { data: LabelUpdateInput; where: LabelWhereUniqueInput }
  ) => LabelPromise;
  updateManyLabels: (
    args: { data: LabelUpdateManyMutationInput; where?: LabelWhereInput }
  ) => BatchPayloadPromise;
  upsertLabel: (
    args: {
      where: LabelWhereUniqueInput;
      create: LabelCreateInput;
      update: LabelUpdateInput;
    }
  ) => LabelPromise;
  deleteLabel: (where: LabelWhereUniqueInput) => LabelPromise;
  deleteManyLabels: (where?: LabelWhereInput) => BatchPayloadPromise;
  createRule: (data: RuleCreateInput) => RulePromise;
  updateRule: (
    args: { data: RuleUpdateInput; where: RuleWhereUniqueInput }
  ) => RulePromise;
  updateManyRules: (
    args: { data: RuleUpdateManyMutationInput; where?: RuleWhereInput }
  ) => BatchPayloadPromise;
  upsertRule: (
    args: {
      where: RuleWhereUniqueInput;
      create: RuleCreateInput;
      update: RuleUpdateInput;
    }
  ) => RulePromise;
  deleteRule: (where: RuleWhereUniqueInput) => RulePromise;
  deleteManyRules: (where?: RuleWhereInput) => BatchPayloadPromise;
  createSchedule: (data: ScheduleCreateInput) => SchedulePromise;
  updateSchedule: (
    args: { data: ScheduleUpdateInput; where: ScheduleWhereUniqueInput }
  ) => SchedulePromise;
  updateManySchedules: (
    args: { data: ScheduleUpdateManyMutationInput; where?: ScheduleWhereInput }
  ) => BatchPayloadPromise;
  upsertSchedule: (
    args: {
      where: ScheduleWhereUniqueInput;
      create: ScheduleCreateInput;
      update: ScheduleUpdateInput;
    }
  ) => SchedulePromise;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (
    args: { data: ServiceUpdateInput; where: ServiceWhereUniqueInput }
  ) => ServicePromise;
  updateManyServices: (
    args: { data: ServiceUpdateManyMutationInput; where?: ServiceWhereInput }
  ) => BatchPayloadPromise;
  upsertService: (
    args: {
      where: ServiceWhereUniqueInput;
      create: ServiceCreateInput;
      update: ServiceUpdateInput;
    }
  ) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createStream: (data: StreamCreateInput) => StreamPromise;
  updateStream: (
    args: { data: StreamUpdateInput; where: StreamWhereUniqueInput }
  ) => StreamPromise;
  updateManyStreams: (
    args: { data: StreamUpdateManyMutationInput; where?: StreamWhereInput }
  ) => BatchPayloadPromise;
  upsertStream: (
    args: {
      where: StreamWhereUniqueInput;
      create: StreamCreateInput;
      update: StreamUpdateInput;
    }
  ) => StreamPromise;
  deleteStream: (where: StreamWhereUniqueInput) => StreamPromise;
  deleteManyStreams: (where?: StreamWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  exclusion: (
    where?: ExclusionSubscriptionWhereInput
  ) => ExclusionSubscriptionPayloadSubscription;
  fragment: (
    where?: FragmentSubscriptionWhereInput
  ) => FragmentSubscriptionPayloadSubscription;
  label: (
    where?: LabelSubscriptionWhereInput
  ) => LabelSubscriptionPayloadSubscription;
  rule: (
    where?: RuleSubscriptionWhereInput
  ) => RuleSubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  stream: (
    where?: StreamSubscriptionWhereInput
  ) => StreamSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ExclusionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "offset_ASC"
  | "offset_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "storeName_ASC"
  | "storeName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "freq_ASC"
  | "freq_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "count_ASC"
  | "count_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Weekday = "MO" | "TU" | "WE" | "TH" | "FR" | "SA" | "SU";

export type FREQ = "MINUTELY" | "SECONDLY" | "DAILY";

export type LabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "name_ASC"
  | "name_DESC"
  | "value_ASC"
  | "value_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FragmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "offset_ASC"
  | "offset_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "storeName_ASC"
  | "storeName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type RuleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "metadata_ASC"
  | "metadata_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StreamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "metadata_ASC"
  | "metadata_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface ScheduleUpdateWithoutStreamDataInput {
  freq?: FREQ;
  duration?: Int;
  count?: Int;
  startTimes?: ScheduleUpdatestartTimesInput;
  weekdays?: ScheduleUpdateweekdaysInput;
  defaultLabels?: LabelUpdateManyWithoutSchedulesInput;
}

export type ExclusionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FragmentUpdateManyWithoutLabelsInput {
  create?:
    | FragmentCreateWithoutLabelsInput[]
    | FragmentCreateWithoutLabelsInput;
  delete?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
  connect?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
  disconnect?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
  update?:
    | FragmentUpdateWithWhereUniqueWithoutLabelsInput[]
    | FragmentUpdateWithWhereUniqueWithoutLabelsInput;
  upsert?:
    | FragmentUpsertWithWhereUniqueWithoutLabelsInput[]
    | FragmentUpsertWithWhereUniqueWithoutLabelsInput;
}

export interface StreamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  schedules_every?: ScheduleWhereInput;
  schedules_some?: ScheduleWhereInput;
  schedules_none?: ScheduleWhereInput;
  exclusions_every?: ExclusionWhereInput;
  exclusions_some?: ExclusionWhereInput;
  exclusions_none?: ExclusionWhereInput;
  fragments_every?: FragmentWhereInput;
  fragments_some?: FragmentWhereInput;
  fragments_none?: FragmentWhereInput;
  AND?: StreamWhereInput[] | StreamWhereInput;
  OR?: StreamWhereInput[] | StreamWhereInput;
  NOT?: StreamWhereInput[] | StreamWhereInput;
}

export interface FragmentUpdateWithWhereUniqueWithoutLabelsInput {
  where: FragmentWhereUniqueInput;
  data: FragmentUpdateWithoutLabelsDataInput;
}

export interface FragmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  offset?: Int;
  offset_not?: Int;
  offset_in?: Int[] | Int;
  offset_not_in?: Int[] | Int;
  offset_lt?: Int;
  offset_lte?: Int;
  offset_gt?: Int;
  offset_gte?: Int;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  storeName?: String;
  storeName_not?: String;
  storeName_in?: String[] | String;
  storeName_not_in?: String[] | String;
  storeName_lt?: String;
  storeName_lte?: String;
  storeName_gt?: String;
  storeName_gte?: String;
  storeName_contains?: String;
  storeName_not_contains?: String;
  storeName_starts_with?: String;
  storeName_not_starts_with?: String;
  storeName_ends_with?: String;
  storeName_not_ends_with?: String;
  stream?: StreamWhereInput;
  labels_every?: LabelWhereInput;
  labels_some?: LabelWhereInput;
  labels_none?: LabelWhereInput;
  AND?: FragmentWhereInput[] | FragmentWhereInput;
  OR?: FragmentWhereInput[] | FragmentWhereInput;
  NOT?: FragmentWhereInput[] | FragmentWhereInput;
}

export interface FragmentUpdateWithoutLabelsDataInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
  stream?: StreamUpdateOneRequiredWithoutFragmentsInput;
}

export interface LabelWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  fragments_every?: FragmentWhereInput;
  fragments_some?: FragmentWhereInput;
  fragments_none?: FragmentWhereInput;
  schedules_every?: ScheduleWhereInput;
  schedules_some?: ScheduleWhereInput;
  schedules_none?: ScheduleWhereInput;
  AND?: LabelWhereInput[] | LabelWhereInput;
  OR?: LabelWhereInput[] | LabelWhereInput;
  NOT?: LabelWhereInput[] | LabelWhereInput;
}

export interface ExclusionCreateManyWithoutStreamInput {
  create?:
    | ExclusionCreateWithoutStreamInput[]
    | ExclusionCreateWithoutStreamInput;
  connect?: ExclusionWhereUniqueInput[] | ExclusionWhereUniqueInput;
}

export interface FragmentCreateInput {
  start: DateTimeInput;
  offset?: Int;
  duration: Int;
  storeName?: String;
  stream: StreamCreateOneWithoutFragmentsInput;
  labels?: LabelCreateManyWithoutFragmentsInput;
}

export interface ExclusionCreateWithoutStreamInput {
  start: DateTimeInput;
  offset?: Int;
  duration: Int;
  storeName?: String;
}

export interface StreamUpdateOneRequiredWithoutFragmentsInput {
  create?: StreamCreateWithoutFragmentsInput;
  update?: StreamUpdateWithoutFragmentsDataInput;
  upsert?: StreamUpsertWithoutFragmentsInput;
  connect?: StreamWhereUniqueInput;
}

export interface FragmentCreateManyWithoutStreamInput {
  create?:
    | FragmentCreateWithoutStreamInput[]
    | FragmentCreateWithoutStreamInput;
  connect?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ServiceWhereInput;
  AND?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  OR?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  NOT?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
}

export interface FragmentCreateWithoutStreamInput {
  start: DateTimeInput;
  offset?: Int;
  duration: Int;
  storeName?: String;
  labels?: LabelCreateManyWithoutFragmentsInput;
}

export interface RuleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RuleWhereInput;
  AND?: RuleSubscriptionWhereInput[] | RuleSubscriptionWhereInput;
  OR?: RuleSubscriptionWhereInput[] | RuleSubscriptionWhereInput;
  NOT?: RuleSubscriptionWhereInput[] | RuleSubscriptionWhereInput;
}

export interface LabelCreateManyWithoutFragmentsInput {
  create?:
    | LabelCreateWithoutFragmentsInput[]
    | LabelCreateWithoutFragmentsInput;
  connect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
}

export interface FragmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FragmentWhereInput;
  AND?: FragmentSubscriptionWhereInput[] | FragmentSubscriptionWhereInput;
  OR?: FragmentSubscriptionWhereInput[] | FragmentSubscriptionWhereInput;
  NOT?: FragmentSubscriptionWhereInput[] | FragmentSubscriptionWhereInput;
}

export interface LabelCreateWithoutFragmentsInput {
  slug: String;
  name: String;
  value: String;
  schedules?: ScheduleCreateManyWithoutDefaultLabelsInput;
}

export type FragmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleCreateManyWithoutDefaultLabelsInput {
  create?:
    | ScheduleCreateWithoutDefaultLabelsInput[]
    | ScheduleCreateWithoutDefaultLabelsInput;
  connect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
}

export interface StreamUpdateInput {
  name?: String;
  metadata?: Json;
  schedules?: ScheduleUpdateManyWithoutStreamInput;
  exclusions?: ExclusionUpdateManyWithoutStreamInput;
  fragments?: FragmentUpdateManyWithoutStreamInput;
}

export interface ScheduleCreateWithoutDefaultLabelsInput {
  freq?: FREQ;
  duration: Int;
  count?: Int;
  startTimes?: ScheduleCreatestartTimesInput;
  weekdays?: ScheduleCreateweekdaysInput;
  stream: StreamCreateOneWithoutSchedulesInput;
}

export type LabelWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  slug?: String;
}>;

export interface StreamCreateOneWithoutSchedulesInput {
  create?: StreamCreateWithoutSchedulesInput;
  connect?: StreamWhereUniqueInput;
}

export interface StreamUpdateDataInput {
  name?: String;
  metadata?: Json;
  schedules?: ScheduleUpdateManyWithoutStreamInput;
  exclusions?: ExclusionUpdateManyWithoutStreamInput;
  fragments?: FragmentUpdateManyWithoutStreamInput;
}

export interface StreamCreateWithoutSchedulesInput {
  name: String;
  metadata?: Json;
  exclusions?: ExclusionCreateManyWithoutStreamInput;
  fragments?: FragmentCreateManyWithoutStreamInput;
}

export type RuleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExclusionUpdateInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
  stream?: StreamUpdateOneRequiredWithoutExclusionsInput;
}

export interface RuleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  end?: DateTimeInput;
  end_not?: DateTimeInput;
  end_in?: DateTimeInput[] | DateTimeInput;
  end_not_in?: DateTimeInput[] | DateTimeInput;
  end_lt?: DateTimeInput;
  end_lte?: DateTimeInput;
  end_gt?: DateTimeInput;
  end_gte?: DateTimeInput;
  includedAnd_every?: LabelWhereInput;
  includedAnd_some?: LabelWhereInput;
  includedAnd_none?: LabelWhereInput;
  includedOr_every?: LabelWhereInput;
  includedOr_some?: LabelWhereInput;
  includedOr_none?: LabelWhereInput;
  excludedAnd_every?: LabelWhereInput;
  excludedAnd_some?: LabelWhereInput;
  excludedAnd_none?: LabelWhereInput;
  excludedOr_every?: LabelWhereInput;
  excludedOr_some?: LabelWhereInput;
  excludedOr_none?: LabelWhereInput;
  AND?: RuleWhereInput[] | RuleWhereInput;
  OR?: RuleWhereInput[] | RuleWhereInput;
  NOT?: RuleWhereInput[] | RuleWhereInput;
}

export interface StreamUpdateOneRequiredWithoutExclusionsInput {
  create?: StreamCreateWithoutExclusionsInput;
  update?: StreamUpdateWithoutExclusionsDataInput;
  upsert?: StreamUpsertWithoutExclusionsInput;
  connect?: StreamWhereUniqueInput;
}

export interface StreamCreateInput {
  name: String;
  metadata?: Json;
  schedules?: ScheduleCreateManyWithoutStreamInput;
  exclusions?: ExclusionCreateManyWithoutStreamInput;
  fragments?: FragmentCreateManyWithoutStreamInput;
}

export interface StreamUpdateWithoutExclusionsDataInput {
  name?: String;
  metadata?: Json;
  schedules?: ScheduleUpdateManyWithoutStreamInput;
  fragments?: FragmentUpdateManyWithoutStreamInput;
}

export interface ServiceCreateInput {
  name: String;
  streams?: StreamCreateManyInput;
}

export interface ScheduleUpdateManyWithoutStreamInput {
  create?:
    | ScheduleCreateWithoutStreamInput[]
    | ScheduleCreateWithoutStreamInput;
  delete?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  connect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  disconnect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  update?:
    | ScheduleUpdateWithWhereUniqueWithoutStreamInput[]
    | ScheduleUpdateWithWhereUniqueWithoutStreamInput;
  upsert?:
    | ScheduleUpsertWithWhereUniqueWithoutStreamInput[]
    | ScheduleUpsertWithWhereUniqueWithoutStreamInput;
}

export interface ScheduleUpdateManyMutationInput {
  freq?: FREQ;
  duration?: Int;
  count?: Int;
  startTimes?: ScheduleUpdatestartTimesInput;
  weekdays?: ScheduleUpdateweekdaysInput;
}

export interface ScheduleUpdateWithWhereUniqueWithoutStreamInput {
  where: ScheduleWhereUniqueInput;
  data: ScheduleUpdateWithoutStreamDataInput;
}

export interface ScheduleCreateInput {
  freq?: FREQ;
  duration: Int;
  count?: Int;
  startTimes?: ScheduleCreatestartTimesInput;
  weekdays?: ScheduleCreateweekdaysInput;
  defaultLabels?: LabelCreateManyWithoutSchedulesInput;
  stream: StreamCreateOneWithoutSchedulesInput;
}

export interface LabelUpdateInput {
  slug?: String;
  name?: String;
  value?: String;
  fragments?: FragmentUpdateManyWithoutLabelsInput;
  schedules?: ScheduleUpdateManyWithoutDefaultLabelsInput;
}

export interface RuleUpdateManyMutationInput {
  name?: String;
  metadata?: Json;
  start?: DateTimeInput;
  end?: DateTimeInput;
}

export interface ScheduleUpdatestartTimesInput {
  set?: String[] | String;
}

export interface ServiceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  streams_every?: StreamWhereInput;
  streams_some?: StreamWhereInput;
  streams_none?: StreamWhereInput;
  AND?: ServiceWhereInput[] | ServiceWhereInput;
  OR?: ServiceWhereInput[] | ServiceWhereInput;
  NOT?: ServiceWhereInput[] | ServiceWhereInput;
}

export interface ScheduleUpdateweekdaysInput {
  set?: Weekday[] | Weekday;
}

export interface LabelUpdateWithWhereUniqueNestedInput {
  where: LabelWhereUniqueInput;
  data: LabelUpdateDataInput;
}

export interface LabelUpdateManyWithoutSchedulesInput {
  create?:
    | LabelCreateWithoutSchedulesInput[]
    | LabelCreateWithoutSchedulesInput;
  delete?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  connect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  disconnect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  update?:
    | LabelUpdateWithWhereUniqueWithoutSchedulesInput[]
    | LabelUpdateWithWhereUniqueWithoutSchedulesInput;
  upsert?:
    | LabelUpsertWithWhereUniqueWithoutSchedulesInput[]
    | LabelUpsertWithWhereUniqueWithoutSchedulesInput;
}

export interface RuleUpdateInput {
  name?: String;
  metadata?: Json;
  start?: DateTimeInput;
  end?: DateTimeInput;
  includedAnd?: LabelUpdateManyInput;
  includedOr?: LabelUpdateManyInput;
  excludedAnd?: LabelUpdateManyInput;
  excludedOr?: LabelUpdateManyInput;
}

export interface LabelUpdateWithWhereUniqueWithoutSchedulesInput {
  where: LabelWhereUniqueInput;
  data: LabelUpdateWithoutSchedulesDataInput;
}

export interface LabelCreateManyInput {
  create?: LabelCreateInput[] | LabelCreateInput;
  connect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
}

export interface LabelUpdateWithoutSchedulesDataInput {
  slug?: String;
  name?: String;
  value?: String;
  fragments?: FragmentUpdateManyWithoutLabelsInput;
}

export interface LabelUpdateManyMutationInput {
  slug?: String;
  name?: String;
  value?: String;
}

export interface ExclusionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  start?: DateTimeInput;
  start_not?: DateTimeInput;
  start_in?: DateTimeInput[] | DateTimeInput;
  start_not_in?: DateTimeInput[] | DateTimeInput;
  start_lt?: DateTimeInput;
  start_lte?: DateTimeInput;
  start_gt?: DateTimeInput;
  start_gte?: DateTimeInput;
  offset?: Int;
  offset_not?: Int;
  offset_in?: Int[] | Int;
  offset_not_in?: Int[] | Int;
  offset_lt?: Int;
  offset_lte?: Int;
  offset_gt?: Int;
  offset_gte?: Int;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  storeName?: String;
  storeName_not?: String;
  storeName_in?: String[] | String;
  storeName_not_in?: String[] | String;
  storeName_lt?: String;
  storeName_lte?: String;
  storeName_gt?: String;
  storeName_gte?: String;
  storeName_contains?: String;
  storeName_not_contains?: String;
  storeName_starts_with?: String;
  storeName_not_starts_with?: String;
  storeName_ends_with?: String;
  storeName_not_ends_with?: String;
  stream?: StreamWhereInput;
  AND?: ExclusionWhereInput[] | ExclusionWhereInput;
  OR?: ExclusionWhereInput[] | ExclusionWhereInput;
  NOT?: ExclusionWhereInput[] | ExclusionWhereInput;
}

export interface ExclusionCreateInput {
  start: DateTimeInput;
  offset?: Int;
  duration: Int;
  storeName?: String;
  stream: StreamCreateOneWithoutExclusionsInput;
}

export interface LabelCreateInput {
  slug: String;
  name: String;
  value: String;
  fragments?: FragmentCreateManyWithoutLabelsInput;
  schedules?: ScheduleCreateManyWithoutDefaultLabelsInput;
}

export interface StreamCreateWithoutExclusionsInput {
  name: String;
  metadata?: Json;
  schedules?: ScheduleCreateManyWithoutStreamInput;
  fragments?: FragmentCreateManyWithoutStreamInput;
}

export interface ScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  freq?: FREQ;
  freq_not?: FREQ;
  freq_in?: FREQ[] | FREQ;
  freq_not_in?: FREQ[] | FREQ;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  defaultLabels_every?: LabelWhereInput;
  defaultLabels_some?: LabelWhereInput;
  defaultLabels_none?: LabelWhereInput;
  stream?: StreamWhereInput;
  AND?: ScheduleWhereInput[] | ScheduleWhereInput;
  OR?: ScheduleWhereInput[] | ScheduleWhereInput;
  NOT?: ScheduleWhereInput[] | ScheduleWhereInput;
}

export interface ScheduleCreateWithoutStreamInput {
  freq?: FREQ;
  duration: Int;
  count?: Int;
  startTimes?: ScheduleCreatestartTimesInput;
  weekdays?: ScheduleCreateweekdaysInput;
  defaultLabels?: LabelCreateManyWithoutSchedulesInput;
}

export interface FragmentUpdateManyMutationInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
}

export interface ScheduleCreateweekdaysInput {
  set?: Weekday[] | Weekday;
}

export interface StreamUpdateWithoutFragmentsDataInput {
  name?: String;
  metadata?: Json;
  schedules?: ScheduleUpdateManyWithoutStreamInput;
  exclusions?: ExclusionUpdateManyWithoutStreamInput;
}

export interface LabelCreateWithoutSchedulesInput {
  slug: String;
  name: String;
  value: String;
  fragments?: FragmentCreateManyWithoutLabelsInput;
}

export interface ExclusionUpdateManyWithoutStreamInput {
  create?:
    | ExclusionCreateWithoutStreamInput[]
    | ExclusionCreateWithoutStreamInput;
  delete?: ExclusionWhereUniqueInput[] | ExclusionWhereUniqueInput;
  connect?: ExclusionWhereUniqueInput[] | ExclusionWhereUniqueInput;
  disconnect?: ExclusionWhereUniqueInput[] | ExclusionWhereUniqueInput;
  update?:
    | ExclusionUpdateWithWhereUniqueWithoutStreamInput[]
    | ExclusionUpdateWithWhereUniqueWithoutStreamInput;
  upsert?:
    | ExclusionUpsertWithWhereUniqueWithoutStreamInput[]
    | ExclusionUpsertWithWhereUniqueWithoutStreamInput;
}

export interface FragmentCreateWithoutLabelsInput {
  start: DateTimeInput;
  offset?: Int;
  duration: Int;
  storeName?: String;
  stream: StreamCreateOneWithoutFragmentsInput;
}

export interface ExclusionUpdateWithWhereUniqueWithoutStreamInput {
  where: ExclusionWhereUniqueInput;
  data: ExclusionUpdateWithoutStreamDataInput;
}

export interface StreamCreateWithoutFragmentsInput {
  name: String;
  metadata?: Json;
  schedules?: ScheduleCreateManyWithoutStreamInput;
  exclusions?: ExclusionCreateManyWithoutStreamInput;
}

export interface ExclusionUpdateWithoutStreamDataInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleWhereInput;
  AND?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  OR?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  NOT?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
}

export interface ExclusionUpsertWithWhereUniqueWithoutStreamInput {
  where: ExclusionWhereUniqueInput;
  update: ExclusionUpdateWithoutStreamDataInput;
  create: ExclusionCreateWithoutStreamInput;
}

export interface ExclusionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExclusionWhereInput;
  AND?: ExclusionSubscriptionWhereInput[] | ExclusionSubscriptionWhereInput;
  OR?: ExclusionSubscriptionWhereInput[] | ExclusionSubscriptionWhereInput;
  NOT?: ExclusionSubscriptionWhereInput[] | ExclusionSubscriptionWhereInput;
}

export interface StreamUpsertWithoutFragmentsInput {
  update: StreamUpdateWithoutFragmentsDataInput;
  create: StreamCreateWithoutFragmentsInput;
}

export interface ServiceUpdateManyMutationInput {
  name?: String;
}

export interface FragmentUpsertWithWhereUniqueWithoutLabelsInput {
  where: FragmentWhereUniqueInput;
  update: FragmentUpdateWithoutLabelsDataInput;
  create: FragmentCreateWithoutLabelsInput;
}

export interface StreamUpdateWithWhereUniqueNestedInput {
  where: StreamWhereUniqueInput;
  data: StreamUpdateDataInput;
}

export interface LabelUpsertWithWhereUniqueWithoutSchedulesInput {
  where: LabelWhereUniqueInput;
  update: LabelUpdateWithoutSchedulesDataInput;
  create: LabelCreateWithoutSchedulesInput;
}

export interface ServiceUpdateInput {
  name?: String;
  streams?: StreamUpdateManyInput;
}

export interface ScheduleUpsertWithWhereUniqueWithoutStreamInput {
  where: ScheduleWhereUniqueInput;
  update: ScheduleUpdateWithoutStreamDataInput;
  create: ScheduleCreateWithoutStreamInput;
}

export type ScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FragmentUpdateManyWithoutStreamInput {
  create?:
    | FragmentCreateWithoutStreamInput[]
    | FragmentCreateWithoutStreamInput;
  delete?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
  connect?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
  disconnect?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
  update?:
    | FragmentUpdateWithWhereUniqueWithoutStreamInput[]
    | FragmentUpdateWithWhereUniqueWithoutStreamInput;
  upsert?:
    | FragmentUpsertWithWhereUniqueWithoutStreamInput[]
    | FragmentUpsertWithWhereUniqueWithoutStreamInput;
}

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface FragmentUpdateWithWhereUniqueWithoutStreamInput {
  where: FragmentWhereUniqueInput;
  data: FragmentUpdateWithoutStreamDataInput;
}

export interface LabelUpdateDataInput {
  slug?: String;
  name?: String;
  value?: String;
  fragments?: FragmentUpdateManyWithoutLabelsInput;
  schedules?: ScheduleUpdateManyWithoutDefaultLabelsInput;
}

export interface FragmentUpdateWithoutStreamDataInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
  labels?: LabelUpdateManyWithoutFragmentsInput;
}

export type StreamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface LabelUpdateManyWithoutFragmentsInput {
  create?:
    | LabelCreateWithoutFragmentsInput[]
    | LabelCreateWithoutFragmentsInput;
  delete?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  connect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  disconnect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  update?:
    | LabelUpdateWithWhereUniqueWithoutFragmentsInput[]
    | LabelUpdateWithWhereUniqueWithoutFragmentsInput;
  upsert?:
    | LabelUpsertWithWhereUniqueWithoutFragmentsInput[]
    | LabelUpsertWithWhereUniqueWithoutFragmentsInput;
}

export interface ScheduleCreateManyWithoutStreamInput {
  create?:
    | ScheduleCreateWithoutStreamInput[]
    | ScheduleCreateWithoutStreamInput;
  connect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
}

export interface LabelUpdateWithWhereUniqueWithoutFragmentsInput {
  where: LabelWhereUniqueInput;
  data: LabelUpdateWithoutFragmentsDataInput;
}

export interface LabelCreateManyWithoutSchedulesInput {
  create?:
    | LabelCreateWithoutSchedulesInput[]
    | LabelCreateWithoutSchedulesInput;
  connect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
}

export interface LabelUpdateWithoutFragmentsDataInput {
  slug?: String;
  name?: String;
  value?: String;
  schedules?: ScheduleUpdateManyWithoutDefaultLabelsInput;
}

export interface StreamCreateOneWithoutFragmentsInput {
  create?: StreamCreateWithoutFragmentsInput;
  connect?: StreamWhereUniqueInput;
}

export interface ScheduleUpdateManyWithoutDefaultLabelsInput {
  create?:
    | ScheduleCreateWithoutDefaultLabelsInput[]
    | ScheduleCreateWithoutDefaultLabelsInput;
  delete?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  connect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  disconnect?: ScheduleWhereUniqueInput[] | ScheduleWhereUniqueInput;
  update?:
    | ScheduleUpdateWithWhereUniqueWithoutDefaultLabelsInput[]
    | ScheduleUpdateWithWhereUniqueWithoutDefaultLabelsInput;
  upsert?:
    | ScheduleUpsertWithWhereUniqueWithoutDefaultLabelsInput[]
    | ScheduleUpsertWithWhereUniqueWithoutDefaultLabelsInput;
}

export interface LabelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LabelWhereInput;
  AND?: LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput;
  OR?: LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput;
  NOT?: LabelSubscriptionWhereInput[] | LabelSubscriptionWhereInput;
}

export interface ScheduleUpdateWithWhereUniqueWithoutDefaultLabelsInput {
  where: ScheduleWhereUniqueInput;
  data: ScheduleUpdateWithoutDefaultLabelsDataInput;
}

export interface StreamUpsertWithWhereUniqueNestedInput {
  where: StreamWhereUniqueInput;
  update: StreamUpdateDataInput;
  create: StreamCreateInput;
}

export interface ScheduleUpdateWithoutDefaultLabelsDataInput {
  freq?: FREQ;
  duration?: Int;
  count?: Int;
  startTimes?: ScheduleUpdatestartTimesInput;
  weekdays?: ScheduleUpdateweekdaysInput;
  stream?: StreamUpdateOneRequiredWithoutSchedulesInput;
}

export interface StreamCreateManyInput {
  create?: StreamCreateInput[] | StreamCreateInput;
  connect?: StreamWhereUniqueInput[] | StreamWhereUniqueInput;
}

export interface StreamUpdateOneRequiredWithoutSchedulesInput {
  create?: StreamCreateWithoutSchedulesInput;
  update?: StreamUpdateWithoutSchedulesDataInput;
  upsert?: StreamUpsertWithoutSchedulesInput;
  connect?: StreamWhereUniqueInput;
}

export interface LabelUpsertWithWhereUniqueNestedInput {
  where: LabelWhereUniqueInput;
  update: LabelUpdateDataInput;
  create: LabelCreateInput;
}

export interface StreamUpdateWithoutSchedulesDataInput {
  name?: String;
  metadata?: Json;
  exclusions?: ExclusionUpdateManyWithoutStreamInput;
  fragments?: FragmentUpdateManyWithoutStreamInput;
}

export interface RuleCreateInput {
  name?: String;
  metadata?: Json;
  start?: DateTimeInput;
  end?: DateTimeInput;
  includedAnd?: LabelCreateManyInput;
  includedOr?: LabelCreateManyInput;
  excludedAnd?: LabelCreateManyInput;
  excludedOr?: LabelCreateManyInput;
}

export interface StreamUpsertWithoutSchedulesInput {
  update: StreamUpdateWithoutSchedulesDataInput;
  create: StreamCreateWithoutSchedulesInput;
}

export interface ScheduleCreatestartTimesInput {
  set?: String[] | String;
}

export interface ScheduleUpsertWithWhereUniqueWithoutDefaultLabelsInput {
  where: ScheduleWhereUniqueInput;
  update: ScheduleUpdateWithoutDefaultLabelsDataInput;
  create: ScheduleCreateWithoutDefaultLabelsInput;
}

export interface StreamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StreamWhereInput;
  AND?: StreamSubscriptionWhereInput[] | StreamSubscriptionWhereInput;
  OR?: StreamSubscriptionWhereInput[] | StreamSubscriptionWhereInput;
  NOT?: StreamSubscriptionWhereInput[] | StreamSubscriptionWhereInput;
}

export interface LabelUpsertWithWhereUniqueWithoutFragmentsInput {
  where: LabelWhereUniqueInput;
  update: LabelUpdateWithoutFragmentsDataInput;
  create: LabelCreateWithoutFragmentsInput;
}

export interface StreamUpdateManyInput {
  create?: StreamCreateInput[] | StreamCreateInput;
  update?:
    | StreamUpdateWithWhereUniqueNestedInput[]
    | StreamUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StreamUpsertWithWhereUniqueNestedInput[]
    | StreamUpsertWithWhereUniqueNestedInput;
  delete?: StreamWhereUniqueInput[] | StreamWhereUniqueInput;
  connect?: StreamWhereUniqueInput[] | StreamWhereUniqueInput;
  disconnect?: StreamWhereUniqueInput[] | StreamWhereUniqueInput;
}

export interface FragmentUpdateInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
  stream?: StreamUpdateOneRequiredWithoutFragmentsInput;
  labels?: LabelUpdateManyWithoutFragmentsInput;
}

export interface ExclusionUpdateManyMutationInput {
  start?: DateTimeInput;
  offset?: Int;
  duration?: Int;
  storeName?: String;
}

export interface StreamUpsertWithoutExclusionsInput {
  update: StreamUpdateWithoutExclusionsDataInput;
  create: StreamCreateWithoutExclusionsInput;
}

export interface FragmentUpsertWithWhereUniqueWithoutStreamInput {
  where: FragmentWhereUniqueInput;
  update: FragmentUpdateWithoutStreamDataInput;
  create: FragmentCreateWithoutStreamInput;
}

export interface ScheduleUpdateInput {
  freq?: FREQ;
  duration?: Int;
  count?: Int;
  startTimes?: ScheduleUpdatestartTimesInput;
  weekdays?: ScheduleUpdateweekdaysInput;
  defaultLabels?: LabelUpdateManyWithoutSchedulesInput;
  stream?: StreamUpdateOneRequiredWithoutSchedulesInput;
}

export interface StreamUpdateManyMutationInput {
  name?: String;
  metadata?: Json;
}

export interface FragmentCreateManyWithoutLabelsInput {
  create?:
    | FragmentCreateWithoutLabelsInput[]
    | FragmentCreateWithoutLabelsInput;
  connect?: FragmentWhereUniqueInput[] | FragmentWhereUniqueInput;
}

export interface StreamCreateOneWithoutExclusionsInput {
  create?: StreamCreateWithoutExclusionsInput;
  connect?: StreamWhereUniqueInput;
}

export interface LabelUpdateManyInput {
  create?: LabelCreateInput[] | LabelCreateInput;
  update?:
    | LabelUpdateWithWhereUniqueNestedInput[]
    | LabelUpdateWithWhereUniqueNestedInput;
  upsert?:
    | LabelUpsertWithWhereUniqueNestedInput[]
    | LabelUpsertWithWhereUniqueNestedInput;
  delete?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  connect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
  disconnect?: LabelWhereUniqueInput[] | LabelWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface StreamPreviousValues {
  id: ID_Output;
  name: String;
  metadata?: Json;
}

export interface StreamPreviousValuesPromise
  extends Promise<StreamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  metadata: () => Promise<Json>;
}

export interface StreamPreviousValuesSubscription
  extends Promise<AsyncIterator<StreamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
}

export interface AggregateFragment {
  count: Int;
}

export interface AggregateFragmentPromise
  extends Promise<AggregateFragment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFragmentSubscription
  extends Promise<AsyncIterator<AggregateFragment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Label {
  id: ID_Output;
  slug: String;
  name: String;
  value: String;
}

export interface LabelPromise extends Promise<Label>, Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  value: () => Promise<String>;
  fragments: <T = FragmentableArray<Fragment>>(
    args?: {
      where?: FragmentWhereInput;
      orderBy?: FragmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  schedules: <T = FragmentableArray<Schedule>>(
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LabelSubscription
  extends Promise<AsyncIterator<Label>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  fragments: <T = Promise<AsyncIterator<FragmentSubscription>>>(
    args?: {
      where?: FragmentWhereInput;
      orderBy?: FragmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  schedules: <T = Promise<AsyncIterator<ScheduleSubscription>>>(
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LabelEdge {
  cursor: String;
}

export interface LabelEdgePromise extends Promise<LabelEdge>, Fragmentable {
  node: <T = LabelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LabelEdgeSubscription
  extends Promise<AsyncIterator<LabelEdge>>,
    Fragmentable {
  node: <T = LabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SchedulePreviousValues {
  id: ID_Output;
  freq: FREQ;
  duration: Int;
  count?: Int;
  startTimes: String[];
  weekdays: Weekday[];
}

export interface SchedulePreviousValuesPromise
  extends Promise<SchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  freq: () => Promise<FREQ>;
  duration: () => Promise<Int>;
  count: () => Promise<Int>;
  startTimes: () => Promise<String[]>;
  weekdays: () => Promise<Weekday[]>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  freq: () => Promise<AsyncIterator<FREQ>>;
  duration: () => Promise<AsyncIterator<Int>>;
  count: () => Promise<AsyncIterator<Int>>;
  startTimes: () => Promise<AsyncIterator<String[]>>;
  weekdays: () => Promise<AsyncIterator<Weekday[]>>;
}

export interface LabelConnection {}

export interface LabelConnectionPromise
  extends Promise<LabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LabelEdge>>() => T;
  aggregate: <T = AggregateLabelPromise>() => T;
}

export interface LabelConnectionSubscription
  extends Promise<AsyncIterator<LabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LabelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLabelSubscription>() => T;
}

export interface FragmentEdge {
  cursor: String;
}

export interface FragmentEdgePromise
  extends Promise<FragmentEdge>,
    Fragmentable {
  node: <T = FragmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FragmentEdgeSubscription
  extends Promise<AsyncIterator<FragmentEdge>>,
    Fragmentable {
  node: <T = FragmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateStream {
  count: Int;
}

export interface AggregateStreamPromise
  extends Promise<AggregateStream>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStreamSubscription
  extends Promise<AsyncIterator<AggregateStream>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Schedule {
  id: ID_Output;
  freq: FREQ;
  duration: Int;
  count?: Int;
  startTimes: String[];
  weekdays: Weekday[];
}

export interface SchedulePromise extends Promise<Schedule>, Fragmentable {
  id: () => Promise<ID_Output>;
  freq: () => Promise<FREQ>;
  duration: () => Promise<Int>;
  count: () => Promise<Int>;
  startTimes: () => Promise<String[]>;
  weekdays: () => Promise<Weekday[]>;
  defaultLabels: <T = FragmentableArray<Label>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  stream: <T = StreamPromise>() => T;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<Schedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  freq: () => Promise<AsyncIterator<FREQ>>;
  duration: () => Promise<AsyncIterator<Int>>;
  count: () => Promise<AsyncIterator<Int>>;
  startTimes: () => Promise<AsyncIterator<String[]>>;
  weekdays: () => Promise<AsyncIterator<Weekday[]>>;
  defaultLabels: <T = Promise<AsyncIterator<LabelSubscription>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  stream: <T = StreamSubscription>() => T;
}

export interface StreamConnection {}

export interface StreamConnectionPromise
  extends Promise<StreamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StreamEdge>>() => T;
  aggregate: <T = AggregateStreamPromise>() => T;
}

export interface StreamConnectionSubscription
  extends Promise<AsyncIterator<StreamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StreamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStreamSubscription>() => T;
}

export interface FragmentConnection {}

export interface FragmentConnectionPromise
  extends Promise<FragmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FragmentEdge>>() => T;
  aggregate: <T = AggregateFragmentPromise>() => T;
}

export interface FragmentConnectionSubscription
  extends Promise<AsyncIterator<FragmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FragmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFragmentSubscription>() => T;
}

export interface ServiceEdge {
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExclusion {
  count: Int;
}

export interface AggregateExclusionPromise
  extends Promise<AggregateExclusion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExclusionSubscription
  extends Promise<AsyncIterator<AggregateExclusion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Fragment {
  id: ID_Output;
  start: DateTimeOutput;
  offset: Int;
  duration: Int;
  storeName?: String;
}

export interface FragmentPromise extends Promise<Fragment>, Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  offset: () => Promise<Int>;
  duration: () => Promise<Int>;
  storeName: () => Promise<String>;
  stream: <T = StreamPromise>() => T;
  labels: <T = FragmentableArray<Label>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FragmentSubscription
  extends Promise<AsyncIterator<Fragment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  offset: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Int>>;
  storeName: () => Promise<AsyncIterator<String>>;
  stream: <T = StreamSubscription>() => T;
  labels: <T = Promise<AsyncIterator<LabelSubscription>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Exclusion {
  id: ID_Output;
  start: DateTimeOutput;
  offset: Int;
  duration: Int;
  storeName?: String;
}

export interface ExclusionPromise extends Promise<Exclusion>, Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  offset: () => Promise<Int>;
  duration: () => Promise<Int>;
  storeName: () => Promise<String>;
  stream: <T = StreamPromise>() => T;
}

export interface ExclusionSubscription
  extends Promise<AsyncIterator<Exclusion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  offset: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Int>>;
  storeName: () => Promise<AsyncIterator<String>>;
  stream: <T = StreamSubscription>() => T;
}

export interface Service {
  id: ID_Output;
  name: String;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  streams: <T = FragmentableArray<Stream>>(
    args?: {
      where?: StreamWhereInput;
      orderBy?: StreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  streams: <T = Promise<AsyncIterator<StreamSubscription>>>(
    args?: {
      where?: StreamWhereInput;
      orderBy?: StreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExclusionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExclusionSubscriptionPayloadPromise
  extends Promise<ExclusionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExclusionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExclusionPreviousValuesPromise>() => T;
}

export interface ExclusionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExclusionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExclusionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExclusionPreviousValuesSubscription>() => T;
}

export interface ScheduleEdge {
  cursor: String;
}

export interface ScheduleEdgePromise
  extends Promise<ScheduleEdge>,
    Fragmentable {
  node: <T = SchedulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdge>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExclusionPreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  offset: Int;
  duration: Int;
  storeName?: String;
}

export interface ExclusionPreviousValuesPromise
  extends Promise<ExclusionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  offset: () => Promise<Int>;
  duration: () => Promise<Int>;
  storeName: () => Promise<String>;
}

export interface ExclusionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExclusionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  offset: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Int>>;
  storeName: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRule {
  count: Int;
}

export interface AggregateRulePromise
  extends Promise<AggregateRule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRuleSubscription
  extends Promise<AsyncIterator<AggregateRule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExclusionEdge {
  cursor: String;
}

export interface ExclusionEdgePromise
  extends Promise<ExclusionEdge>,
    Fragmentable {
  node: <T = ExclusionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExclusionEdgeSubscription
  extends Promise<AsyncIterator<ExclusionEdge>>,
    Fragmentable {
  node: <T = ExclusionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RuleConnection {}

export interface RuleConnectionPromise
  extends Promise<RuleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RuleEdge>>() => T;
  aggregate: <T = AggregateRulePromise>() => T;
}

export interface RuleConnectionSubscription
  extends Promise<AsyncIterator<RuleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RuleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRuleSubscription>() => T;
}

export interface FragmentSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FragmentSubscriptionPayloadPromise
  extends Promise<FragmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FragmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FragmentPreviousValuesPromise>() => T;
}

export interface FragmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FragmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FragmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FragmentPreviousValuesSubscription>() => T;
}

export interface Rule {
  id: ID_Output;
  name?: String;
  metadata?: Json;
  start?: DateTimeOutput;
  end?: DateTimeOutput;
}

export interface RulePromise extends Promise<Rule>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  metadata: () => Promise<Json>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  includedAnd: <T = FragmentableArray<Label>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  includedOr: <T = FragmentableArray<Label>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  excludedAnd: <T = FragmentableArray<Label>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  excludedOr: <T = FragmentableArray<Label>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RuleSubscription
  extends Promise<AsyncIterator<Rule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  includedAnd: <T = Promise<AsyncIterator<LabelSubscription>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  includedOr: <T = Promise<AsyncIterator<LabelSubscription>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  excludedAnd: <T = Promise<AsyncIterator<LabelSubscription>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  excludedOr: <T = Promise<AsyncIterator<LabelSubscription>>>(
    args?: {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FragmentPreviousValues {
  id: ID_Output;
  start: DateTimeOutput;
  offset: Int;
  duration: Int;
  storeName?: String;
}

export interface FragmentPreviousValuesPromise
  extends Promise<FragmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  start: () => Promise<DateTimeOutput>;
  offset: () => Promise<Int>;
  duration: () => Promise<Int>;
  storeName: () => Promise<String>;
}

export interface FragmentPreviousValuesSubscription
  extends Promise<AsyncIterator<FragmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  offset: () => Promise<AsyncIterator<Int>>;
  duration: () => Promise<AsyncIterator<Int>>;
  storeName: () => Promise<AsyncIterator<String>>;
}

export interface StreamSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StreamSubscriptionPayloadPromise
  extends Promise<StreamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StreamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StreamPreviousValuesPromise>() => T;
}

export interface StreamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StreamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StreamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StreamPreviousValuesSubscription>() => T;
}

export interface Stream {
  id: ID_Output;
  name: String;
  metadata?: Json;
}

export interface StreamPromise extends Promise<Stream>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  metadata: () => Promise<Json>;
  schedules: <T = FragmentableArray<Schedule>>(
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exclusions: <T = FragmentableArray<Exclusion>>(
    args?: {
      where?: ExclusionWhereInput;
      orderBy?: ExclusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fragments: <T = FragmentableArray<Fragment>>(
    args?: {
      where?: FragmentWhereInput;
      orderBy?: FragmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StreamSubscription
  extends Promise<AsyncIterator<Stream>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
  schedules: <T = Promise<AsyncIterator<ScheduleSubscription>>>(
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exclusions: <T = Promise<AsyncIterator<ExclusionSubscription>>>(
    args?: {
      where?: ExclusionWhereInput;
      orderBy?: ExclusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fragments: <T = Promise<AsyncIterator<FragmentSubscription>>>(
    args?: {
      where?: FragmentWhereInput;
      orderBy?: FragmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LabelSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LabelSubscriptionPayloadPromise
  extends Promise<LabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LabelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LabelPreviousValuesPromise>() => T;
}

export interface LabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LabelPreviousValuesSubscription>() => T;
}

export interface ServicePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface LabelPreviousValues {
  id: ID_Output;
  slug: String;
  name: String;
  value: String;
}

export interface LabelPreviousValuesPromise
  extends Promise<LabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  slug: () => Promise<String>;
  name: () => Promise<String>;
  value: () => Promise<String>;
}

export interface LabelPreviousValuesSubscription
  extends Promise<AsyncIterator<LabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  slug: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleConnection {}

export interface ScheduleConnectionPromise
  extends Promise<ScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScheduleEdge>>() => T;
  aggregate: <T = AggregateSchedulePromise>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface StreamEdge {
  cursor: String;
}

export interface StreamEdgePromise extends Promise<StreamEdge>, Fragmentable {
  node: <T = StreamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StreamEdgeSubscription
  extends Promise<AsyncIterator<StreamEdge>>,
    Fragmentable {
  node: <T = StreamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleSubscriptionPayloadPromise
  extends Promise<ScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchedulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValuesPromise>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface ExclusionConnection {}

export interface ExclusionConnectionPromise
  extends Promise<ExclusionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExclusionEdge>>() => T;
  aggregate: <T = AggregateExclusionPromise>() => T;
}

export interface ExclusionConnectionSubscription
  extends Promise<AsyncIterator<ExclusionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExclusionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExclusionSubscription>() => T;
}

export interface RulePreviousValues {
  id: ID_Output;
  name?: String;
  metadata?: Json;
  start?: DateTimeOutput;
  end?: DateTimeOutput;
}

export interface RulePreviousValuesPromise
  extends Promise<RulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  metadata: () => Promise<Json>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface RulePreviousValuesSubscription
  extends Promise<AsyncIterator<RulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  metadata: () => Promise<AsyncIterator<Json>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RuleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RuleSubscriptionPayloadPromise
  extends Promise<RuleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RulePreviousValuesPromise>() => T;
}

export interface RuleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RuleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RuleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RulePreviousValuesSubscription>() => T;
}

export interface ServiceConnection {}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface AggregateLabel {
  count: Int;
}

export interface AggregateLabelPromise
  extends Promise<AggregateLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLabelSubscription
  extends Promise<AsyncIterator<AggregateLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RuleEdge {
  cursor: String;
}

export interface RuleEdgePromise extends Promise<RuleEdge>, Fragmentable {
  node: <T = RulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RuleEdgeSubscription
  extends Promise<AsyncIterator<RuleEdge>>,
    Fragmentable {
  node: <T = RuleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchedule {
  count: Int;
}

export interface AggregateSchedulePromise
  extends Promise<AggregateSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

export type Json = any;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Exclusion",
    embedded: false
  },
  {
    name: "FREQ",
    embedded: false
  },
  {
    name: "Fragment",
    embedded: false
  },
  {
    name: "Label",
    embedded: false
  },
  {
    name: "Rule",
    embedded: false
  },
  {
    name: "Schedule",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "Stream",
    embedded: false
  },
  {
    name: "Weekday",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
